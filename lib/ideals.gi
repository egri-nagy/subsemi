################################################################################
##
## SubSemi
##
## Distributing subsemigroup enumeration along the ideal structure
##
## Copyright (C) 2013  Attila Egri-Nagy
##

#actually building the Rees factor semigroup as the right regular representation
#of the quotient by ideal I
InstallGlobalFunction(ReesFactorHomomorphism,
function(I)
  local quotienthom,regrepisom; 
  quotienthom:=HomomorphismQuotientSemigroup(ReesCongruenceOfSemigroupIdeal(I));
  regrepisom:=IsomorphismTransformationSemigroup(Range(quotienthom));
  return CompositionMapping(regrepisom, quotienthom);
end);

InstallGlobalFunction(RFHNonZeroPreImages,
function (l,rfh)
  local result,t,preimgs;
  result := [];
  for t in l do
    preimgs := PreImages(rfh,t);
    if Size(preimgs) = 1 then
      Add(result, preimgs[1]);
    fi;
  od;
  return result;
end);

InstallGlobalFunction(SubSgpsByIdeals,
function(S,I)
  local mtS,mtI,mtT,mtSminusI, rfh,T,Tsubs,Isubs, emptyset,subs,realsubs,torsos;
  mtS := MulTab(S);
  emptyset := BlistList(Indices(mtS),[]);
  mtI := MulTab(I);
  #recoding the subsemigroups of ideal as subsgps of the original
  Isubs := List(AsList(SubSgpsByMinExtensions(mtI)),
              x->ReCodeIndicatorSet(x,SortedElements(mtI),SortedElements(mtS)));
  
  rfh := ReesFactorHomomorphism(I);
  T := Range(rfh); #T=S\I
  mtT := MulTab(T);
  subs := AsList(SubSgpsByMinExtensions(mtT));
  realsubs := List(subs, x->ElementsByIndicatorSet(x,SortedElements(mtT)));
  torsos := Unique(List(realsubs, x->RFHNonZeroPreImages(x,rfh)));
  Tsubs := List(torsos, x->IndicatorSetOfElements(x,SortedElements(mtS)));
  
  Add(Isubs,emptyset);
  Add(Tsubs,emptyset);
  #taking the subsgps generated by the unions
  return Combiner(Tsubs, Isubs, mtS);
end);

# two sets plainly
InstallGlobalFunction(Combiner,
function(A,B,mt)
  local result, a,b;
  result := HeavyBlistContainer();
  for a in A do
    for b in B do
      AddSet(result, SgpInMulTab(UnionBlist(a,b),mt));
    od;
  od;
  return AsList(result);
end);

# A bigger, B potentially inside
InstallGlobalFunction(ConjugacyClassCombiner,
function(A,B,mt)        
  local Cas, Ca, Cbs,result;
  result := [];
  Cas := List(A,x->ConjugacyClassOfSet(x,mt));#precalculate a's conjugacy classes
  Cbs := List(B,x->ConjugacyClassOfSet(x,mt));#precalculate B's conjugacy classes
  for Ca in Cas do
    Append(result, AsList(CombineConjugacyClassWithClasses(Ca,Cbs,mt)));
  od;
  return result;
end);

#calculates all distinct pairwise unions of sets in A and sets in B
Unions := function(A,B,mt)
  return Unique(List(EnumeratorOfCartesianProduct(A,B),UnionBlist));
end;

InstallGlobalFunction(CombineConjugacyClassWithClasses,
function(Ca,Cbs,mt)
  local hashtab,Cb,combined;
  hashtab := HeavyBlistContainer();
  #for each union collecting its representative
  for Cb in Cbs do
    Perform(Unions(Ca,Cb,mt),
            function(x) AddSet(hashtab,ConjugacyClassRep(x,mt));end);
  od;
  Info(SubSemiInfoClass,1,Concatenation(String(Size(hashtab))," unionreps"));
  #collect what they generate
  combined := AsList(hashtab);
  hashtab := HeavyBlistContainer();
  Perform(combined, function(x) AddSet(hashtab, SgpInMulTab(x,mt));end);
  Info(SubSemiInfoClass,1,Concatenation(String(Size(hashtab))," sgps"));
  #sgps may be in the same conjugacy class, so making them unique
  combined := AsList(hashtab);
  hashtab := HeavyBlistContainer();
  Perform(combined, function(x) AddSet(hashtab, ConjugacyClassRep(x,mt));end);
  return hashtab;
end);

#doing the ideal thingy
SubSgpsByIdeal := function(I,G)
  local rfh, T, mtT, Treps, preimgs, elts, tmp, Tuppertorsos, Textended, filter, result, S,s,mtS;
  S := Parent(I); mtS := MulTab(S,G); 
  #get the Rees quotient as ts
  rfh := ReesFactorHomomorphism(I);
  T := Range(rfh);
  #calculate its subsgp classes
  mtT := MulTab(T,G,rfh);
  Treps := AsSortedList(AsList(SubSgpsByMinExtensions(mtT)));
  #mapping back the subs of the quotient to the original
  preimgs := List(SortedElements(mtT),x->PreImages(rfh,x));
  #from preimageset to elements, getting rid of zero by failing it
  elts := List(preimgs,function(x) if Size(x)> 1 then return fail;
                                   else return x[1];fi;end);
  tmp := List(Treps, x->ElementsByIndicatorSet(x,elts));
  Perform(tmp, function(x) if fail in x then
                             Remove(x, Position(x,fail));fi;end);
  Tuppertorsos := List(Unique(tmp),x-> IndicatorSetOfElements(x,mtS));
  Print("UTS:", Size(Unique(Tuppertorsos)),"\n");
  Textended := List(Tuppertorsos, x-> SgpInMulTab(x,mtS));
  filter := IndicatorSetOfElements(AsList(I),SortedElements(mtS));
  result := [];
  for s in Textended do
    Append(result,AsList(
            SubSgpsByMinExtensionsParametrized(mtS,s,filter,Stack())));
  od;
  return result; #TODO duplicates when the ideal has only one element
end;

 I3 := SymmetricInverseMonoid(3);
