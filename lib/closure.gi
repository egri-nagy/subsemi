################################################################################
##
## SubSemi
##
## Calculating the closure of a subarray of a multiplication table, i.e.
## a semigroup generated by some elements inside the multiplication table of
## a bigger semigroup.
##
## Copyright (C) 2013-2015  Attila Egri-Nagy
##

#TODO get rid of this by working on lists only
#returning a mutable bitlist from a bitlist or a list of pos integers
MutableBlist := function(set, universe)
  if IsBlist(set) then #to make it type agnostic
    return ShallowCopy(set);
  else
    return BlistList(universe,set);
  fi;
end;
MakeReadOnlyGlobal("MutableBlist");

#TODO duplicated code, do proper abstraction!
#trying to leave the function as early as possible
InstallGlobalFunction(IsInClosure,
function(base,extension,elt,mt)
  local waiting,diff,closure,i,j,tab;
  tab := Rows(mt);
  waiting := MutableBlist(extension, Indices(mt));
  closure := ShallowCopy(base);
  if closure[elt] or waiting[elt] then return true; fi;
  diff := BlistList(Indices(mt),[]);
  while SizeBlist(waiting) > 0 do
    i := Position(waiting,true); # it is not empty, so this is ok, not a queue
    if elt = i then return true; fi;
    for j in Indices(mt) do
      if closure[j] then
        diff[tab[j][i]] := true; #scanning the ith column
        diff[tab[i][j]] := true; #scanning the ith row
      fi;
    od;
    diff[tab[i][i]] := true; # adding the diagonal
    SubtractBlist(diff,closure); #now it is a real diff
    if diff[elt] then return true; fi;
    UniteBlist(waiting, diff);
    SubtractBlist(diff,waiting);#cleaning for reusing diff object
    closure[i] := true; #adding i
    waiting[i] := false; #removing i from the waiting
  od;
  return false;
end);

#the closure of base the extension to closure (subsgp)
# when adding a new point we check for new entries (filtered out by existing positions)
InstallGlobalFunction(ClosureByIncrements,
function(base,extension,mt)
  local waiting,diff,closure,i,j,tab, f;
  tab := Rows(mt);
  waiting := DuplicateFreeStack();
  f := function(x) Store(waiting,x);end; #todo generic storefunction in DUST
  Perform(extension, f);
  closure := Set(base);
  diff := [];
  while not IsEmpty(waiting) do
    i := Retrieve(waiting);
    for j in closure do
      AddSet(diff, tab[j][i]);
      AddSet(diff, tab[i][j]);
    od;
    AddSet(diff, tab[i][i]); # adding the diagonal
    diff := Difference(diff,closure); #now it is a real diff
    Perform(diff, f);
    AddSet(closure, i); #adding i
  od;
  return closure;
end);

#alternative method
InstallGlobalFunction(ClosureByIncrementsAndLocalTables,
function(base,extension,mt)
  local waiting,closure,i,v,tab,f;
  tab := LocalTables(mt);
  waiting := DuplicateFreeStack();
  f := function(x) Store(waiting,x);end; #todo generic storefunction in DUST
  Perform(extension, f);
  closure := Set(base);
  while not IsEmpty(waiting) do
    i := Retrieve(waiting);
    AddSet(closure, i); #adding i
    #what shall we include?
    for v in tab[i] do
      if not v[1] in closure and ForAny(v[2], x-> x in closure) then
        Store(waiting, v[1]);
        AddSet(closure, v[1]); #boosting: if in waiting then it is in
      fi;
    od;
  od;
  return closure;
end);

#alternative method: we check all the missing points whether to include or not
InstallGlobalFunction(ClosureByComplement,
function(base,extension,mt)
  local complement,closure,i,globtab,flag;
  globtab := GlobalTables(mt);
  closure := Union(base, extension);
  complement := Difference(Indices(mt), closure);
  flag := true; # true means we still have work to do
  while flag do
    flag := false;
    for i in complement do
      if ForAny(globtab[i],
                function(bt) #do we include i?
                  return bt[1] in closure
                         and ForAny(bt[2],
                                    y->y in closure);end) then
          AddSet(closure,i);
          flag := true;
        fi;
    od;
    complement := Difference(Indices(mt), closure);
  od;
  return closure;
end);

InstallGlobalFunction(SgpInMulTab,
function(arg)
  #arg[1] - gens
  #arg[2] - mt
  #arg[3] - closure function
  if IsBound(arg[3]) then
    return arg[3]([],arg[1],arg[2]);
  else
    return ClosureByIncrements([],arg[1],arg[2]);
  fi;
end);

InstallGlobalFunction(IsMaximalSubSgp,
function(set,mt)
  local diff, full;
  diff := ShallowCopy(Indices(mt));
  SubtractSet(diff, AsSet(ListBlist(Indices(mt), set)));
  if IsEmpty(diff) then return false; fi;
  full := BlistList(Indices(mt),Indices(mt));
  return ForAll(diff, i-> full = ClosureByIncrements(set,[i],mt));
end);

InstallGlobalFunction(IsClosedSubTable,
function(set,mt)
  return IsEmpty(MissingElements(set,mt));
end);


#just to kickstart the closure, calculate the missing elements
#this may not be a closure
InstallGlobalFunction(MissingElements,
function(gens,mt)
  local completion, rows;
  rows := Rows(mt);
  completion := [];
  Perform(Tuples(ListBlist(Indices(mt), gens),2),
          function(p)
            if (not gens[rows[p[1]][p[2]]]) then
              AddSet(completion,rows[p[1]][p[2]]);
            fi;end);
  return completion;
end);
