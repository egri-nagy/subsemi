################################################################################
##
## SubSemi
##
## Calculating the closure of a subarray of a multiplication table, i.e.
## a semigroup generated by some elements inside the multiplication table of
## a bigger semigroup.
##
## Copyright (C) 2013-2015  Attila Egri-Nagy
##

# Blists are lot faster like 4x-7x

#returning a mutable bitlist from a bitlist or a list of pos integers
MutableBlist := function(set, universe)
  if IsBlist(set) then #to make it type agnostic
    return ShallowCopy(set);
  else
    return BlistList(universe,set);
  fi;
end;
MakeReadOnlyGlobal("MutableBlist");

#TODO duplicated code, do proper abstraction!
#trying to leave the function as early as possible
InstallGlobalFunction(IsInClosure,
function(base,extension,elt,mt)
  local waiting,diff,closure,i,j,tab;
  tab := Rows(mt);
  waiting := MutableBlist(extension, Indices(mt));
  closure := ShallowCopy(base);
  if closure[elt] or waiting[elt] then return true; fi;
  diff := BlistList(Indices(mt),[]);
  while SizeBlist(waiting) > 0 do
    i := Position(waiting,true); # it is not empty, so this is ok, not a queue
    if elt = i then return true; fi;
    for j in Indices(mt) do
      if closure[j] then
        diff[tab[j][i]] := true; #scanning the ith column
        diff[tab[i][j]] := true; #scanning the ith row
      fi;
    od;
    diff[tab[i][i]] := true; # adding the diagonal
    SubtractBlist(diff,closure); #now it is a real diff
    if diff[elt] then return true; fi;
    UniteBlist(waiting, diff);
    SubtractBlist(diff,waiting);#cleaning for reusing diff object
    closure[i] := true; #adding i
    waiting[i] := false; #removing i from the waiting
  od;
  return false;
end);


#the closure of base the extension to closure (subsgp)
# when adding a new point we check for new entries (filtered out by existing positions)
InstallGlobalFunction(ClosureByIncrements,
function(base,extension,mt)
  local diff,closure,i,j,tab;
  if base[extension] then return base; fi;
  tab := Rows(mt);
  diff := BlistList(Indices(mt),[]);
  diff[extension] := true;
  closure := ShallowCopy(base);
  while SizeBlist(diff) > 0 do
    i := Position(diff,true); # just get the first
    closure[i] := true; #adding i
    for j in Indices(mt) do
      if closure[j] then
        diff[tab[j][i]] := true; #scanning the ith column
        diff[tab[i][j]] := true; #scanning the ith row
      fi;
    od;
    SubtractBlist(diff,closure); #now it is a real diff
  od;
  return closure;
end);

#alternative method
InstallGlobalFunction(ClosureByIncrementsAndLocalTables,
function(base,extension,mt)
  local waiting,closure,i,v,tab;
  tab := LocalTables(mt);
  waiting := MutableBlist(extension, Indices(mt));
  closure := ShallowCopy(base);
  while SizeBlist(waiting) > 0 do
    i := Position(waiting,true); # it is not empty, so this is ok
    closure[i] := true; #adding i
    #what shall we include?
    for v in tab[i] do
      if not closure[v[1]] and ForAny(v[2], x->closure[x]) then
        waiting[v[1]] := true;
        closure[v[1]] := true; #boosting: if in waiting then it is in
      fi;
    od;
    waiting[i] := false; #removing i from the waiting list
  od;
  return closure;
end);

#alternative method: we check all the missing points whether to include or not
InstallGlobalFunction(ClosureByComplement,
function(base,extension,mt)
  local complement,closure,i,globtab,flag;
  globtab := GlobalTables(mt);
  closure := UnionBlist([base, MutableBlist(extension, Indices(mt))]);
  complement := DifferenceBlist(FullSet(mt), closure);
  flag := true; # true means we still have work to do
  while flag do
    flag := false;
    for i in Indices(mt) do
      if complement[i] then #is it in the complement
        if ForAny(globtab[i], function(bt) #do we include i?
             return closure[bt[1]] and ForAny(bt[2], y->closure[y]);end) then
          closure[i] := true;
          flag := true;
        fi;
      fi;
    od;
    complement := DifferenceBlist(FullSet(mt), closure);
  od;
  return closure;
end);

InstallGlobalFunction(SgpInMulTab,
function(arg)
  #arg[1] - gens
  #arg[2] - mt
  #arg[3] - closure function
  local closure, i, f, gens;
  gens := arg[1]; #ListBlist(Indices(mt), arg[1]);
  if IsBound(arg[3]) then
    f := arg[3];
  else
    f := ClosureByIncrements;
  fi;
  closure := f(EmptySet(arg[2]), gens[1], arg[2]);
  for i in [2..Length(gens)] do
    closure := f(closure, gens[i], arg[2]);
  od;
  return closure;
end);

InstallGlobalFunction(IsMaximalSubSgp,
function(set,mt)
  local diff, full;
  diff := ShallowCopy(Indices(mt));
  SubtractSet(diff, AsSet(ListBlist(Indices(mt), set)));
  if IsEmpty(diff) then return false; fi;
  full := BlistList(Indices(mt),Indices(mt));
  return ForAll(diff, i-> full = ClosureByIncrements(set,i,mt));
end);

InstallGlobalFunction(IsClosedSubTable,
function(set,mt)
  return IsEmpty(MissingElements(set,mt));
end);


#just to kickstart the closure, calculate the missing elements
#this may not be a closure
InstallGlobalFunction(MissingElements,
function(gens,mt)
  local completion, rows;
  rows := Rows(mt);
  completion := [];
  Perform(Tuples(ListBlist(Indices(mt), gens),2),
          function(p)
            if (not gens[rows[p[1]][p[2]]]) then
              AddSet(completion,rows[p[1]][p[2]]);
            fi;end);
  return completion;
end);
